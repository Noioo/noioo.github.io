{"meta":{"title":"Hello World","subtitle":null,"description":null,"author":"Senyag","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-11-08T09:15:33.000Z","updated":"2018-11-08T09:15:33.689Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-11-08T09:16:06.243Z","updated":"2018-11-08T09:16:06.243Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-11-08T09:15:52.775Z","updated":"2018-11-08T09:15:52.775Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Index","date":"2018-11-08T09:21:01.416Z","updated":"2018-11-08T09:21:01.416Z","comments":true,"path":"index/index.html","permalink":"http://yoursite.com/index/index.html","excerpt":"","text":"Develop 程序开发的相关知识索引. JavaGoErlangRustC/C++Front-endOthersDatabaseTool"}],"posts":[{"title":"SpringFramework｜Resource","slug":"SpringFramework｜Resource","date":"2018-11-08T09:56:33.000Z","updated":"2018-11-08T10:01:17.712Z","comments":true,"path":"2018/11/fca2/","link":"","permalink":"http://yoursite.com/2018/11/fca2/","excerpt":"Resource为我们提供了一种更好的方式去访问底层资源文件. 且更便于被Spring IoC容器所管理.","text":"Resource为我们提供了一种更好的方式去访问底层资源文件. 且更便于被Spring IoC容器所管理. Spring Framework | Resource spring version: 5.1.1.RELEASE spring-context spring-core spring-beans OverviewSpring’s Resource interface is meant to be a more capable interface for abstracting access to low-level resources. Resource Bean - ResourceBean.java123456789101112131415161718192021222324252627package yag.resource;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.core.io.Resource;import java.io.IOException;public class ResourceBean implements ApplicationContextAware &#123; private ApplicationContext applicationContext; public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; public void getResource() throws IOException&#123; Resource resource = applicationContext.getResource(\"resource/config.txt\"); System.out.println(\"文件名: \" + resource.getFilename()); System.out.println(\"文件URL:\" + resource.getURL()); System.out.println(\"文件URI:\" + resource.getURI()); System.out.println(\"文件描述:\" + resource.getDescription()); &#125;&#125; xml config - resource/resource-beans.xml1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"myResource\" class=\"yag.resource.ResourceBean\"&gt; &lt;/bean&gt;&lt;/beans&gt; the file - resource/config.txt just a txt… runner - Runner.java12345678910111213141516package yag.resource;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;public class Runner &#123; public static void main(String[] args) throws IOException &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"resource/resource-beans.xml\"); ResourceBean resourceBean = (ResourceBean)context.getBean(\"myResource\"); resourceBean.getResource(); &#125;&#125; ResourceBeansome most important methods Resource的主要方法 getInputStream(): Locates and opens the resource, returning an InputStreamfor reading from the resource. It is expected that each invocation returns a fresh InputStream. It is the responsibility of the caller to close the stream. exists(): Returns a boolean indicating whether this resource actually exists in physical form. isOpen(): Returns a boolean indicating whether this resource represents a handle with an open stream. If true, the InputStream cannot be read multiple times and must be read once only and then closed to avoid resource leaks. Returns false for all usual resource implementations, with the exception of InputStreamResource. getDescription(): Returns a description for this resource, to be used for error output when working with the resource. This is often the fully qualified file name or the actual URL of the resource. Resource implementations Resource的下层实现 UrlResource: UrlResource wraps a java.net.URL and can be used to access any object that is normally accessible with a URL, such as files, an HTTP target, an FTP target, and others. ClassPathResource: This class represents a resource that should be obtained from the classpath. FileSystemResource: This is a Resource implementation for java.io.File and java.nio.file.Pathhandles. ServletContextResource: This is a Resource implementation for ServletContext resources that interprets relative paths within the relevant web application’s root directory. InputStreamResource: An InputStreamResource is a Resource implementation for a given InputStream. ByteArrayResource: This is a Resource implementation for a given byte array. It creates aByteArrayInputStream for the given byte array. The ResourceLoaderAware interface 用于被Resource Bean继承实现的接口. The ResourceLoaderAware interface is a special marker interface that identifies objects that expect to be provided with a ResourceLoader reference. 1234public interface ResourceLoaderAware &#123; void setResourceLoader(ResourceLoader resourceLoader);&#125; When a class implements ResourceLoaderAware and is deployed into an application context (as a Spring-managed bean), it is recognized as ResourceLoaderAware by the application context. The application context then invokes setResourceLoader(ResourceLoader), supplying itself as the argument (remember, all application contexts in Spring implement the ResourceLoaderinterface). ConfigResources as Dependencies(xml)123&lt;bean id=\"myBean\" class=\"...\"&gt; &lt;property name=\"template\" value=\"some/resource/path/myTemplate.txt\"/&gt;&lt;/bean&gt; about prefixclasspath: 1&lt;property name=\"template\" value=\"classpath:some/resource/path/myTemplate.txt\"&gt; file: 1&lt;property name=\"template\" value=\"file:///some/resource/path/myTemplate.txt\"/&gt; RunnerApplication Contexts and Resource Paths12ApplicationContext ctx = new FileSystemXmlApplicationContext(\"classpath:conf/appContext.xml\"); // or use moreThe ResourceLoaderThe ResourceLoaderAware interface is a special marker interface that identifies objects that expect to be provided with a ResourceLoader reference.","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"Java","slug":"Develop/Java","permalink":"http://yoursite.com/categories/Develop/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring-framework","slug":"spring-framework","permalink":"http://yoursite.com/tags/spring-framework/"}]},{"title":"spring-ioc-summary","slug":"SpringFramework｜IoC Summary","date":"2018-11-08T08:24:17.000Z","updated":"2018-11-08T09:57:28.400Z","comments":true,"path":"2018/11/f19b/","link":"","permalink":"http://yoursite.com/2018/11/f19b/","excerpt":"Ioc—Inversion of Control，即“控制反转”, 在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。简单来说就是将实例创建这样的事情交由第三方容器去处理. 在此对Spring IoC部分的功能做一个大致的概述, 😋不过不会那么细致, 只涉及常用的功能. 也不过多介绍Spring中的一些概念.","text":"Ioc—Inversion of Control，即“控制反转”, 在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。简单来说就是将实例创建这样的事情交由第三方容器去处理. 在此对Spring IoC部分的功能做一个大致的概述, 😋不过不会那么细致, 只涉及常用的功能. 也不过多介绍Spring中的一些概念. Spring Framework | IoCversion spring version: 5.1.1.RELEASE spring-context spring-core spring-beans 示例 从一个简单的示例来入手这个框架, 并尽可能多的贯穿整个框架功能体系. 背景: 让BeanUser, 调用Bean里面的方法. (即BeanUser需要一个Bean实例) bean - Bean.java 12345public class Bean&#123; public void sayHello()&#123; System.out.print(\"Hello\"); &#125;&#125; 一个简单的类, 当然根据实际开发需求, 我们或许需要一个POJO.. bean使用者 - BeanUser.java12345678910public class BeanUser&#123; private Bean bean; public void setBean(Bean bean)&#123; this.bean = bean; &#125; // use bean's method public void useBean()&#123; bean.sayHello(); &#125;&#125; 它通过setBean()函数注入Bean对象, 而这个对象将会由Spring来注入. Spring 配置 - spring-beans.xml1234567&lt;!-- ignore the dtd --&gt;&lt;beans&gt; &lt;bean id=\"bean\" class=\"yag.Bean\"&gt;&lt;/bean&gt; &lt;bean id=\"beanUser\" class=\"yag.BeanUser\"&gt; &lt;property name=\"bean\" ref=\"bean\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 执行者 - Runner.java1234567public void forXmlConfig()&#123; // load the config ApplicationContext context = new ClassPathXmlApplicationContext(\"spring-beans.xml\"); // get bean BeanUser beanUser = (BeanUser)context.getBean(BeanUser.class); beanUser.useBean(); // use bean&#125; 罗列部分代码. 小结从上面看到, 一共四个代码片段, 可以将框架分为三个功能部分来学习: Bean(Bean 和 BeanUser都是Bean) Bean的配置 执行者 要注意的是, 不是说写在XML配置中的就要划分给配置, 有些内容实际上是为其他部分准备的. 这个划分是按照功能来划分的. Bean 部分 了解Bean定义以及一些附加性功能. 要了解Bean, 就需要从依赖入手. 什么是依赖? 简单的说就是需要谁的实例就依赖谁. 依赖注入 - 需要一个Bean实例在示例中所使用的方式是Setter函数注入(又称设值注入, 即通过一个函数的参数来注入), 这种方式源于JavaBean. 还有一种注入称为构造注入, 不过由于Spring的框架”主张”, 它被划分到自动装配中去了. 在BeanUser类中的setter方法一般如下: 12private Bean bean;public void setBean(Bean bean)&#123; this.bean = bean; &#125; 在Spring中的配置有两种: XML和JavaConfig XML Bean定义: &lt;bean id=&quot;bean&quot; class=&quot;yag.Bean&quot;&gt;&lt;/bean&gt; BeanUse注入定义: 123&lt;bean id=\"beanUser\" class=\"yag.BeanUser\"&gt; &lt;property name=\"bean\" ref=\"bean\"/&gt;&lt;/bean&gt; JavaConfig^JavaConfig 自动装配 - 自动注入Bean实例 自动装配指的是自动注入Bean示例. 目的是节约过多的代码量, 有助于Bean的管理. 在Spring中自动装配有三种: byName - 通过注入参数的属性名来匹配Bean id 12345&lt;!-- byName --&gt;&lt;!-- 去掉了property, 新增了属性autowire=\"byName\" --&gt;&lt;bean id=\"beanUser\" class=\"yag.BeanUser\" autowire=\"byName\"&gt; &lt;!-- BeanUser将用属性名来匹配Bean id --&gt;&lt;/bean&gt; byType - 通过注入参数的类型来匹配Bean 类型. 12345&lt;!-- byType --&gt;&lt;bean id=\"beanUser\" class=\"yag.BeanUser\" autowire=\"byType\"&gt; &lt;!-- 它将会以定义的属性值的类型来匹配这里的Bean名 --&gt;&lt;/bean&gt;&lt;!-- 因为是根据类型匹配的, 我们甚至连给这个Bean起id都不用 --&gt; constructor-arg - 构造注入, 指定Bean id 1234&lt;!-- constructor-arg --&gt;&lt;bean class=\"yag.BeanUser\"&gt; &lt;constructor-arg ref=\"bean\"/&gt;&lt;/bean&gt; 限定操作 - 精准匹配到Bean123// on construction method:public BeanUser(@Qualifier(value=\"the_bean_id\")Bean bean)&#123;this.bean=bean;&#125;// on setter method: same as construction method 这个一般用于配合自动装配使用, 当自动装配匹配不到时, 再用这个注解进一步匹配到具体的Bean id. 需要在配置文件中启用注解: &lt;context:annotation-config/&gt; Config 部分Bean的作用域12&lt;bean id=\"...\" class=\"...\" scope=\"&#123;singleton(default)|prototype|request|session|global-session&#125;\"/&gt; 作用域 描述 singleton 在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，默认值 prototype 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean() request 每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境 session 同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境 global-session 一般用于Portlet应用环境，该运用域仅适用于WebApplicationContext环境 Bean的继承关系12345678&lt;!-- 父 bean 自身不能被实例化，因为它是不完整的，而且它也被明确地标记为抽象的。--&gt;&lt;bean id=\"beanTeamplate\" abstract=\"true\"&gt; &lt;property name=\"message1\" value=\"Hello World!\"/&gt;&lt;/bean&gt;&lt;bean id=\"helloChina\" class=\"com.Hello\" parent=\"beanTeamplate\"&gt; &lt;property name=\"message1\" value=\"Hello China!\"/&gt;&lt;/bean&gt; 配置importJava Config12345678910import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class JavaConfig&#123; @Bean // or: @Bean(name=\"beanId\") public Bean bean()&#123; return new Bean(); &#125;&#125; Bean类, JavaConfig类都需要被注解 @Configuration 需要在XML配置文件中启用注解: 12&lt;context:annotation-config/&gt;&lt;context:component-scan base-package=\"yag\"/&gt; ImportImport的作用是整合配置文件, 让Runner^Runner只需要加载一个配置文件即可. xml configYou can use the application context constructor to load bean definitions from all these XML fragments. 12345678&lt;beans&gt; &lt;!-- runner just only load this xml file --&gt; &lt;import resource=\"services.xml\"/&gt; &lt;import resource=\"resources/messageSource.xml\"/&gt; &lt;import resource=\"/resources/themeSource.xml\"/&gt; &lt;bean id=\"bean1\" class=\"...\"/&gt; &lt;bean id=\"bean2\" class=\"...\"/&gt;&lt;/beans&gt; java config123456789101112131415161718@Configurationpublic class ConfigA &#123; @Bean public A a() &#123; return new A(); &#125;&#125;@Configuration@Import(ConfigA.class)public class ConfigB &#123; // runner just only load it @Bean public B b() &#123; return new B(); &#125;&#125; Runner 部分1234567891011121314151617import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public void forXmlConfig()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"spring-beans.xml\"); // get Bean BeanUser beanUser = (BeanUser)context.getBean(BeanUser.class);&#125;public void forJavaConfig()&#123; ApplicationContext context = new AnnotationConfigApplicationContext(JavaConfig.class); // get Bean BeanUser beanUser = (BeanUser)context.getBean(BeanUser.class); //or getBean(\"BeanId\")&#125; 其他内容 JSR-250 JSR-330 关于Bean 容器 Bean Context Factorys","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"Java","slug":"Develop/Java","permalink":"http://yoursite.com/categories/Develop/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring-framework","slug":"spring-framework","permalink":"http://yoursite.com/tags/spring-framework/"}]}]}